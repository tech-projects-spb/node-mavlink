"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sendSigned=exports.send=exports.createMavLinkStream=exports.serializeMavlinkPacket=exports.parseMavlinkPacket=exports.MavLinkPacketParser=exports.MavLinkPacketSplitter=exports.MavLinkPacket=exports.MavLinkPacketSignature=exports.MavLinkProtocolV2=exports.MavLinkProtocolV1=exports.MavLinkProtocol=exports.MavLinkPacketHeader=void 0;const stream_1=require("stream"),crypto_1=require("crypto"),mavlink_mappings_1=require("mavlink-mappings"),mavlink_mappings_2=require("mavlink-mappings"),utils_1=require("./utils"),logger_1=require("./logger"),serialization_1=require("./serialization");class MavLinkPacketHeader{constructor(){this.magic=0,this.payloadLength=0,this.incompatibilityFlags=0,this.compatibilityFlags=0,this.seq=0,this.sysid=0,this.compid=0,this.msgid=0}}exports.MavLinkPacketHeader=MavLinkPacketHeader;class MavLinkProtocol{constructor(){this.log=logger_1.Logger.getLogger(this)}data(t,n){this.log.trace("Deserializing",n.MSG_NAME,"with payload of size",t.length);const e=new n;return n.FIELDS.forEach(s=>{const i=serialization_1.DESERIALIZERS[s.type];if(!i)throw new Error(`Unknown field type ${s.type}`);e[s.name]=i(t,s.offset,s.length)}),e}}exports.MavLinkProtocol=MavLinkProtocol,MavLinkProtocol.NAME="unknown",MavLinkProtocol.START_BYTE=0,MavLinkProtocol.PAYLOAD_OFFSET=0,MavLinkProtocol.CHECKSUM_LENGTH=2,MavLinkProtocol.SYS_ID=254,MavLinkProtocol.COMP_ID=1;class MavLinkProtocolV1 extends MavLinkProtocol{constructor(t=MavLinkProtocol.SYS_ID,n=MavLinkProtocol.COMP_ID){super(),this.sysid=t,this.compid=n}serialize(t,n){this.log.trace("Serializing message (seq:",n,")");const e=t.constructor,s=Buffer.from(new Uint8Array(MavLinkProtocolV1.PAYLOAD_OFFSET+e.PAYLOAD_LENGTH+MavLinkProtocol.CHECKSUM_LENGTH));s.writeUInt8(MavLinkProtocolV1.START_BYTE,0),s.writeUInt8(e.PAYLOAD_LENGTH,1),s.writeUInt8(n,2),s.writeUInt8(this.sysid,3),s.writeUInt8(this.compid,4),s.writeUInt8(e.MSG_ID,5),e.FIELDS.forEach(r=>{const o=serialization_1.SERIALIZERS[r.type];if(!o)throw new Error(`Unknown field type ${r.type}: serializer not found`);o(t[r.name],s,r.offset+MavLinkProtocolV1.PAYLOAD_OFFSET,r.length)});const i=(0,mavlink_mappings_1.x25crc)(s,1,2,e.MAGIC_NUMBER);return s.writeUInt16LE(i,s.length-2),s}header(t){this.log.trace("Reading header from buffer (len:",t.length,")");const n=t.readUInt8(0);if(n!==MavLinkProtocolV1.START_BYTE)throw new Error(`Invalid start byte (expected: ${MavLinkProtocolV1.START_BYTE}, got ${n})`);const e=new MavLinkPacketHeader;return e.magic=n,e.payloadLength=t.readUInt8(1),e.seq=t.readUInt8(2),e.sysid=t.readUInt8(3),e.compid=t.readUInt8(4),e.msgid=t.readUInt8(5),e}crc(t){this.log.trace("Reading crc from buffer (len:",t.length,")");const n=t.readUInt8(1);return t.readUInt16LE(MavLinkProtocolV1.PAYLOAD_OFFSET+n)}payload(t){this.log.trace("Reading payload from buffer (len:",t.length,")");const n=t.readUInt8(1),e=t.slice(MavLinkProtocolV1.PAYLOAD_OFFSET,MavLinkProtocolV1.PAYLOAD_OFFSET+n),s=Buffer.from(new Uint8Array(255-e.length));return Buffer.concat([e,s])}}exports.MavLinkProtocolV1=MavLinkProtocolV1,MavLinkProtocolV1.NAME="MAV_V1",MavLinkProtocolV1.START_BYTE=254,MavLinkProtocolV1.PAYLOAD_OFFSET=6;class MavLinkProtocolV2 extends MavLinkProtocol{constructor(t=MavLinkProtocol.SYS_ID,n=MavLinkProtocol.COMP_ID,e=MavLinkProtocolV2.INCOMPATIBILITY_FLAGS,s=MavLinkProtocolV2.COMPATIBILITY_FLAGS){super(),this.sysid=t,this.compid=n,this.incompatibilityFlags=e,this.compatibilityFlags=s}serialize(t,n){this.log.trace("Serializing message (seq:",n,")");const e=t.constructor,s=Buffer.from(new Uint8Array(MavLinkProtocolV2.PAYLOAD_OFFSET+e.PAYLOAD_LENGTH+MavLinkProtocol.CHECKSUM_LENGTH));s.writeUInt8(MavLinkProtocolV2.START_BYTE,0),s.writeUInt8(this.incompatibilityFlags,2),s.writeUInt8(this.compatibilityFlags,3),s.writeUInt8(n,4),s.writeUInt8(this.sysid,5),s.writeUInt8(this.compid,6),s.writeUIntLE(e.MSG_ID,7,3),e.FIELDS.forEach(c=>{const h=serialization_1.SERIALIZERS[c.type];if(!h)throw new Error(`Unknown field type ${c.type}: serializer not found`);h(t[c.name],s,c.offset+MavLinkProtocolV2.PAYLOAD_OFFSET,c.length)});const i=this.calculateTruncatedPayloadLength(s);s.writeUInt8(i,1);const r=s.slice(0,MavLinkProtocolV2.PAYLOAD_OFFSET+i+MavLinkProtocol.CHECKSUM_LENGTH),o=(0,mavlink_mappings_1.x25crc)(r,1,2,e.MAGIC_NUMBER);return r.writeUInt16LE(o,r.length-MavLinkProtocol.CHECKSUM_LENGTH),r}sign(t,n,e,s=Date.now()){this.log.trace("Signing message");const i=Buffer.concat([t,Buffer.from(new Uint8Array(MavLinkPacketSignature.SIGNATURE_LENGTH))]),r=new MavLinkPacketSignature(i);return r.linkId=n,r.timestamp=s,r.signature=r.calculate(e),i}calculateTruncatedPayloadLength(t){let n=t.length;for(let e=t.length-MavLinkProtocol.CHECKSUM_LENGTH-1;e>=MavLinkProtocolV2.PAYLOAD_OFFSET;e--)if(n=e,t[e]!==0){n++;break}return n-MavLinkProtocolV2.PAYLOAD_OFFSET}header(t){this.log.trace("Reading header from buffer (len:",t.length,")");const n=t.readUInt8(0);if(n!==MavLinkProtocolV2.START_BYTE)throw new Error(`Invalid start byte (expected: ${MavLinkProtocolV2.START_BYTE}, got ${n})`);const e=new MavLinkPacketHeader;return e.magic=n,e.payloadLength=t.readUInt8(1),e.incompatibilityFlags=t.readUInt8(2),e.compatibilityFlags=t.readUInt8(3),e.seq=t.readUInt8(4),e.sysid=t.readUInt8(5),e.compid=t.readUInt8(6),e.msgid=t.readUIntLE(7,3),e}crc(t){this.log.trace("Reading crc from buffer (len:",t.length,")");const n=t.readUInt8(1);return t.readUInt16LE(MavLinkProtocolV2.PAYLOAD_OFFSET+n)}payload(t){this.log.trace("Reading payload from buffer (len:",t.length,")");const n=t.readUInt8(1),e=t.slice(MavLinkProtocolV2.PAYLOAD_OFFSET,MavLinkProtocolV2.PAYLOAD_OFFSET+n),s=Buffer.from(new Uint8Array(255-e.length));return Buffer.concat([e,s])}signature(t,n){return this.log.trace("Reading signature from buffer (len:",t.length,")"),n.incompatibilityFlags&MavLinkProtocolV2.IFLAG_SIGNED?new MavLinkPacketSignature(t):null}}exports.MavLinkProtocolV2=MavLinkProtocolV2,MavLinkProtocolV2.NAME="MAV_V2",MavLinkProtocolV2.START_BYTE=253,MavLinkProtocolV2.PAYLOAD_OFFSET=10,MavLinkProtocolV2.INCOMPATIBILITY_FLAGS=0,MavLinkProtocolV2.COMPATIBILITY_FLAGS=0,MavLinkProtocolV2.IFLAG_SIGNED=1;const KNOWN_PROTOCOLS_BY_STX={[MavLinkProtocolV1.START_BYTE]:MavLinkProtocolV1,[MavLinkProtocolV2.START_BYTE]:MavLinkProtocolV2};class MavLinkPacketSignature{constructor(t){this.buffer=t}static key(t){return(0,crypto_1.createHash)("sha256").update(t).digest()}get offset(){return this.buffer.length-MavLinkPacketSignature.SIGNATURE_LENGTH}get linkId(){return this.buffer.readUInt8(this.offset)}set linkId(t){this.buffer.writeUInt8(this.offset)}get timestamp(){return this.buffer.readUIntLE(this.offset+1,6)}set timestamp(t){this.buffer.writeUIntLE(t,this.offset+1,6)}get signature(){return this.buffer.slice(this.offset+7,this.offset+7+6).toString("hex")}set signature(t){this.buffer.write(t,this.offset+7,"hex")}calculate(t){return(0,crypto_1.createHash)("sha256").update(t).update(this.buffer.slice(0,this.buffer.length-6)).digest("hex").substr(0,12)}matches(t){return this.calculate(t)===this.signature}toString(){return`linkid: ${this.linkId}, timestamp ${this.timestamp}, signature ${this.signature}`}}exports.MavLinkPacketSignature=MavLinkPacketSignature,MavLinkPacketSignature.SIGNATURE_LENGTH=13;class MavLinkPacket{constructor(t,n=new MavLinkPacketHeader,e=Buffer.from(new Uint8Array(255)),s=0,i=new MavLinkProtocolV1,r=null){this.buffer=t,this.header=n,this.payload=e,this.crc=s,this.protocol=i,this.signature=r}debug(){return`Packet (proto: ${this.protocol.constructor.NAME}, sysid: ${this.header.sysid}, compid: ${this.header.compid}, msgid: ${this.header.msgid}, seq: ${this.header.seq}, plen: ${this.header.payloadLength}, magic: ${mavlink_mappings_2.MSG_ID_MAGIC_NUMBER[this.header.msgid]} (${(0,utils_1.hex)(mavlink_mappings_2.MSG_ID_MAGIC_NUMBER[this.header.msgid])}), crc: ${(0,utils_1.hex)(this.crc,4)}`+this.signatureToString(this.signature)+")"}signatureToString(t){return t?`, ${t.toString()}`:""}}exports.MavLinkPacket=MavLinkPacket;var PacketValidationResult;(function(a){a[a.VALID=0]="VALID",a[a.INVALID=1]="INVALID",a[a.UNKNOWN=2]="UNKNOWN"})(PacketValidationResult||(PacketValidationResult={}));class MavLinkPacketSplitter extends stream_1.Transform{constructor(t={},n=()=>{}){super(t),this.log=logger_1.Logger.getLogger(this),this.buffer=Buffer.from([]),this.onCrcError=null,this._validPackagesCount=0,this._unknownPackagesCount=0,this._invalidPackagesCount=0,this.onCrcError=n}_transform(t,n,e){for(this.buffer=Buffer.concat([this.buffer,t]);this.buffer.byteLength>0;){const s=this.findStartOfPacket(this.buffer);if(s===null)break;s>0&&(this.buffer=this.buffer.slice(s)),this.log.debug("Found potential packet start at",s);const i=this.getPacketProtocol(this.buffer);if(this.log.debug("Packet protocol is",i.NAME),this.buffer.length<i.PAYLOAD_OFFSET+MavLinkProtocol.CHECKSUM_LENGTH){this.log.debug("Current buffer shorter than the shortest message - skipping");break}const r=this.readPacketLength(this.buffer,i);if(this.log.debug("Expected buffer length:",r,`(${(0,utils_1.hex)(r)})`),this.buffer.length<r){this.log.debug("Current buffer is not fully retrieved yet - skipping");break}else this.log.debug("Current buffer length:",this.buffer.length,`(${(0,utils_1.hex)(this.buffer.length,4)})`);const o=this.buffer.slice(0,r);switch(this.log.debug("Recognized buffer length:",o.length,`(${(0,utils_1.hex)(o.length,2)})`),this.validatePacket(o,i)){case PacketValidationResult.VALID:this.log.debug("Found a valid packet"),this._validPackagesCount++,this.push(o),this.buffer=this.buffer.slice(r);break;case PacketValidationResult.INVALID:this.log.debug("Found an invalid packet - skipping"),this._invalidPackagesCount++,this.buffer=this.buffer.slice(1);break;case PacketValidationResult.UNKNOWN:this.log.debug("Found an unknown packet - skipping"),this._unknownPackagesCount++,this.buffer=this.buffer.slice(r);break}}e(null)}findStartOfPacket(t){const n=t.indexOf(MavLinkProtocolV1.START_BYTE),e=t.indexOf(MavLinkProtocolV2.START_BYTE);return n>=0&&e>=0?n<e?n:e:n>=0?n:e>=0?e:null}getPacketProtocol(t){return KNOWN_PROTOCOLS_BY_STX[t.readUInt8(0)]||null}readPacketLength(t,n){const e=t.readUInt8(1);return n.PAYLOAD_OFFSET+e+MavLinkProtocol.CHECKSUM_LENGTH+(this.isV2Signed(t)?MavLinkPacketSignature.SIGNATURE_LENGTH:0)}validatePacket(t,n){const e=new n,s=e.header(t),i=mavlink_mappings_2.MSG_ID_MAGIC_NUMBER[s.msgid];if(i){const r=e.crc(t),o=this.isV2Signed(t)?MavLinkPacketSignature.SIGNATURE_LENGTH+MavLinkProtocol.CHECKSUM_LENGTH:MavLinkProtocol.CHECKSUM_LENGTH,c=(0,mavlink_mappings_1.x25crc)(t,1,o,i);if(r===c)return PacketValidationResult.VALID;{const h=[`CRC error; expected: ${c} (${(0,utils_1.hex)(c,4)}), got ${r} (${(0,utils_1.hex)(r,4)});`,`msgid: ${s.msgid} (${(0,utils_1.hex)(s.msgid)}),`,`seq: ${s.seq} (${(0,utils_1.hex)(s.seq)}),`,`plen: ${s.payloadLength} (${(0,utils_1.hex)(s.payloadLength)}),`,`magic: ${i} (${(0,utils_1.hex)(i)})`];return this.log.warn(h.join(" ")),this.onCrcError(t),PacketValidationResult.INVALID}}else return this.log.debug(`Unknown message with id ${s.msgid} (magic number not found) - skipping`),PacketValidationResult.UNKNOWN}isV2Signed(t){if(t.readUInt8(0)===MavLinkProtocolV2.START_BYTE)return!!(t.readUInt8(2)&MavLinkProtocolV2.IFLAG_SIGNED)}get validPackages(){return this._validPackagesCount}resetValidPackagesCount(){this._validPackagesCount=0}get invalidPackages(){return this._invalidPackagesCount}resetInvalidPackagesCount(){this._invalidPackagesCount=0}get unknownPackagesCount(){return this._unknownPackagesCount}resetUnknownPackagesCount(){this._unknownPackagesCount=0}}exports.MavLinkPacketSplitter=MavLinkPacketSplitter;class MavLinkPacketParser extends stream_1.Transform{constructor(t={}){super({...t,objectMode:!0}),this.log=logger_1.Logger.getLogger(this)}getProtocol(t){const n=t.readUInt8(0);switch(n){case MavLinkProtocolV1.START_BYTE:return new MavLinkProtocolV1;case MavLinkProtocolV2.START_BYTE:return new MavLinkProtocolV2;default:throw new Error(`Unknown protocol '${(0,utils_1.hex)(n)}'`)}}_transform(t,n,e){const s=this.getProtocol(t),i=s.header(t),r=s.payload(t),o=s.crc(t),c=s instanceof MavLinkProtocolV2?s.signature(t,i):null,h=new MavLinkPacket(t,i,r,o,s,c);e(null,h)}}exports.MavLinkPacketParser=MavLinkPacketParser;function getProtocol(a){const t=a.readUInt8(0);switch(t){case MavLinkProtocolV1.START_BYTE:return new MavLinkProtocolV1;case MavLinkProtocolV2.START_BYTE:return new MavLinkProtocolV2;default:throw new Error(`Unknown protocol '${(0,utils_1.hex)(t)}'`)}}function parseMavlinkPacket(a){const t=getProtocol(a),n=t.header(a),e=t.payload(a),s=t.crc(a),i=t instanceof MavLinkProtocolV2?t.signature(a,n):null;return new MavLinkPacket(a,n,e,s,t,i)}exports.parseMavlinkPacket=parseMavlinkPacket;function serializeMavlinkPacket(a,t){return new MavLinkProtocolV2().serialize(a,t)}exports.serializeMavlinkPacket=serializeMavlinkPacket;function createMavLinkStream(a,t){return a.pipe(new MavLinkPacketSplitter({},t)).pipe(new MavLinkPacketParser)}exports.createMavLinkStream=createMavLinkStream;let seq=0;async function send(a,t,n=new MavLinkProtocolV1){return new Promise((e,s)=>{const i=n.serialize(t,seq++);seq&=255,a.write(i,r=>{r?s(r):e(i.length)})})}exports.send=send;async function sendSigned(a,t,n,e=1,s=MavLinkProtocol.SYS_ID,i=MavLinkProtocol.COMP_ID,r=Date.now()){return new Promise((o,c)=>{const h=new MavLinkProtocolV2(s,i,MavLinkProtocolV2.IFLAG_SIGNED),d=h.serialize(t,seq++);seq&=255;const l=h.sign(d,e,n,r);a.write(l,g=>{g?c(g):o(l.length)})})}exports.sendSigned=sendSigned;